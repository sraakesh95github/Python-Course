from scipy.optimize import fsolve
import matplotlib.pyplot as plt
import numpy as np
import scipy.constants as ct
from scipy.optimize import leastsq
# Ignore the warnings generated in runtime during
# the leastsq operation
import warnings

# Scientific required for the execution of the program
ISAT_CONST = 1e-9  # Saturation current of the diode
N_CONST = 1.7  # Ideality factor
R_CONST = 11e3  # Resistor in series with the diode
T_CONST1 = 350  # Temperature coefficient of the diode for problem 1
q = ct.physical_constants["atomic unit of charge"][0]  # Get the value of the atomic unit of charge
k = ct.physical_constants["Boltzmann constant"][0]  # Boltzmann constant
T_CONST2 = 375  # Temperature set for problem 2
A = 1e-8  # Area of cross-section of the diode
RES_ERR_THRESH = 10e-6  # Init the average residual threshold for the diode current
res_avg = 1

# Ignore the warnings generated by leastsq operations
warnings.simplefilter("ignore")

###########################################
# PROBLEM 1
###########################################

# Initialize the voltage range for the diode
Vs_init = np.arange(0.1, 2.5, 0.1)  # Create a voltage range with starting value as 0.1V and end value as 2.5V with a step size of 0.1V
step_size = (2.5 - 0.1) / 0.1
V = [1 for i in range(int(step_size+1))]  # Creates a list with step_size number of 1000's

# Equation of current passing through the diode
# This function is both by problems 1 and 2
def Idiode(Vd, Is, n, T):
    return Is * (np.exp((Vd * q) / (n * k * T)) - 1)

# Define the error equation that is obtained by nodal analysis
# This is obtained by performing a nodal analysis on the circuit
def errorFunc(Vd, Vs, R, Is, n, T):
    x = (Vd / R) - (Vs / R) + Idiode(Vd, Is, n, T)
    return x

# Get the final value of the voltage that gives the least error
diode_voltage = fsolve(errorFunc, V, args=(Vs_init, R_CONST,ISAT_CONST, N_CONST, T_CONST1))
diode_current = Idiode(diode_voltage, ISAT_CONST, N_CONST, T_CONST1)

# Setup the parameters for the plot
fig, (ax1, ax2) = plt.subplots(1,2, figsize=(15,7))
ax1.set_title("Problem 1 plot")
ax1.set_ylabel("Diode current in log scale")
ax1.set_xlabel("Voltage in volts")

# Plot the graph between the log of the diode current and the source voltage
ax1.plot(Vs_init, np.log10(diode_current), label="Source Voltage vs Diode Current")

# Plot the graph between the log of the diode current and the diode voltage
ax1.plot(diode_voltage, np.log10(diode_current), label="Diode Voltage vs Diode Current")

# Include the legends in the plot
ax1.legend()

###########################################
# PROBLEM 2
###########################################

# Initialize the actual values until the least square estimation is started
# These are initialized as list as the output to the least squares is an array of numbers from the values are
# to be indexed for passing in the next iteration
n = [1.5]  # Ideality factor of the diode
R = [10e3]  # Resistance in series with the diode
phi = [0.8]  # Barrier height for the diode

# Read a text file in python
f = open("DiodeIV.txt", 'r')

# Read line by line from the text file
lines = f.readlines()

# Initialize the values of source voltages and diode currents
Vs_lst = []
Id_actual_lst = []

# get the values of Vs and Id from the text file
# Perform a strip to remove the spaces
# Perform a split to give an output of a list of values of the stripped values
for line in lines:
    a = line.strip().split()
    Vs_lst.append(a[0])
    Id_actual_lst.append(a[1])

# Convert the list of strings to an array for calculations on them
Vs_arr = [float(i) for i in Vs_lst]
Id_actual_arr = [float(i) for i in Id_actual_lst]

# Diode current equation inclusive of the source voltage and actual diode current as the input parameters
# The previous diode current function "Idiode" took the diode voltage as the input parameter
# Notice the Vs - (I * R) used instead of Vd as in Idiode
def Idiode2(Is, Vs, R, n, I):
    result = Is * (np.exp((((Vs - (I * R)) * q) / (n * k * T_CONST2))) - 1)
    return result

# Define the equation for the saturation current of the diode
def Isat(phi):
    return (A * (T_CONST2**2) * np.exp(-phi*q/(k*T_CONST2)))

# Define the residual functions
# The steps within the function remain the same even though the names of the residul functions
# # are different. This is done to maintain a different order of inputs
# The error values are taken to be the absolute values of the difference between the actual diode current
# values from the DiodeIV.txt and the predicted values using the R, phi and n using the least squares
def residual_phi(phi, n, R):
    Is_temp = Isat(phi)
    return np.absolute(Id_actual_arr - Idiode2(Is_temp, Vs_arr, R, n, Id_actual_arr))

def residual_n(n, phi, R):
    Is_temp = Isat(phi)
    return np.absolute(Id_actual_arr - Idiode2(Is_temp, Vs_arr, R, n, Id_actual_arr))

def residual_R(R, n, phi):
    Is_temp = Isat(phi)
    return np.absolute(Id_actual_arr - Idiode2(Is_temp, Vs_arr, R, n, Id_actual_arr))

# Use a loop until the desired value converges to an accurate value within an error
# threshold
# Use count to keep track of the number of iterations before the convergence
count = 1

while(res_avg > RES_ERR_THRESH):

    # Perform the least squares optimization to get the values of R, phi and n
    # Here the values of R, phi and n are taken from the previous iteration
    # During the first iteration, it takes the initialized values
    R = leastsq(residual_R, R[0], args=(n[0], phi[0]))
    # print("LeastSq (R): " + str(R))
    phi = leastsq(residual_phi, phi[0], args=(n[0], R[0]))
    # print("LeastSq: (phi)" + str(R[0]))
    n = leastsq(residual_n, n[0], args=(phi[0], R[0]))

    # Get the average residual using one of the residual functions
    # This step calculates the average residual current which is the deviation of all the actual values (provided
    # in the DiodeIV.txt from the predicted values (by substituting the current iteration values of R, n and phi)
    res_avg = np.average(np.absolute(residual_phi(phi[0], n[0], R[0])))

    # Tracking parameters printed
    print("< Iter#: {0} ; phi: {1:.4f} ; n: {2:.4f} ; R: {3:.2f} ; Residual: {4:.3e} >" \
          .format(count, phi[0][0], n[0][0], R[0][0], res_avg))

    # Increment the tracking count for every iteration
    count+=1

# Indexed predicted values
R_pred = R[0][0]
n_pred = n[0][0]
phi_pred = phi[0][0]

# Print the final values of R, n and phi
print("\n\nEstimated resistance (R): {0:.2f} \u03A9" .format(R_pred))
print("Estimated ideality factor (n): {0:.2f}" .format(n_pred))
print("Estimated phi: {0:.3f}" .format(phi_pred))
print("Number of iterations to converge: {0}".format(count))

# Init the diode voltage for prediction
Vd_init = [1 for i in range(len(Vs_arr))]

# Calculate the saturation current, diode voltage, diode current based upon the predicted values of phi
Is_pred = Isat(phi_pred)
diode_voltage_pred = fsolve(errorFunc, Vd_init, args=(Vs_arr, R_pred, Is_pred, n_pred, T_CONST2))
diode_current_pred = Idiode(diode_voltage_pred, Is_pred, n_pred, T_CONST2)

# Set axes params for the plot
ax2.set_xlabel("Diode voltage in volts")
ax2.set_ylabel("Diode current in log scale")
ax2.set_title("Problem 2 plot")

# Plot the given values of Source voltage and diode current in DiodeIV.txt (Actual values)
ax2.plot(Vs_arr[1:], np.log10(Id_actual_arr[1:]), label="Actual")

# Plot the given values of diode current and diode voltage in DiodeIV.txt (Predicted values)
ax2.plot(Vs_arr[1:], np.log10(diode_current_pred[1:]), label="Predicted")
ax2.legend()
plt.show()



